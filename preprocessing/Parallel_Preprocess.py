import numpy as np
import pandas as pd
import json
import itertools
import random
from concurrent.futures import ProcessPoolExecutor
from sklearn.preprocessing import StandardScaler, MinMaxScaler



def apply_transformations(df, column, transformations):
    """Applies randomly selected transformations to a column."""
    df = df.copy()

    for transform in transformations:
        if transform == "differencing":
            df[column] = df[column].diff().fillna(df[column].iloc[0])
        elif transform == "log_transformation":
            df[column] = np.log1p(df[column])
        elif transform == "rolling_mean_normalization":
            df[column] = df[column] - df[column].rolling(window=3, min_periods=1).mean()

    return df


def apply_scaling(df, column, method):
    """Applies scaling to a column."""
    df = df.copy()
    scaler = StandardScaler() if method == "standardization" else MinMaxScaler()
    df[column] = scaler.fit_transform(df[[column]])
    return df


def preprocess_timeseries(df, report, transformation_choice, scaling_choice):
    """Applies selected transformations and scaling method."""
    df = df.copy()
    column = report["preprocessing_recommendations"]["feature_engineering"][0]["column"]

    # Apply chosen transformations
    df = apply_transformations(df, column, transformation_choice)

    # Apply chosen scaling
    df = apply_scaling(df, column, scaling_choice)

    return df


def run_experiment(df, report, transformation_choice, scaling_choice, experiment_id):
    """Runs a preprocessing variation."""
    print(
        f"Running Experiment {experiment_id} with {transformation_choice} and {scaling_choice}..."
    )
    processed_df = preprocess_timeseries(
        df, report, transformation_choice, scaling_choice
    )
    return experiment_id, processed_df


def run_parallel_experiments(df, report, num_experiments=4):
    """Runs multiple preprocessing variations in parallel."""
    results = {}

    # Extract possible transformations and scaling methods
    column = report["preprocessing_recommendations"]["feature_engineering"][0]["column"]
    transformations = report["preprocessing_recommendations"]["feature_engineering"][0][
        "suggested_transformations"
    ]
    scaling_methods = report["preprocessing_recommendations"]["feature_scaling"][0][
        "recommended_method"
    ]

    # Generate different transformation combinations
    transformation_combinations = list(
        itertools.chain.from_iterable(
            itertools.combinations(transformations, r)
            for r in range(1, len(transformations) + 1)
        )
    )

    # Select a few random preprocessing variations
    chosen_variations = random.sample(
        transformation_combinations,
        min(len(transformation_combinations), num_experiments),
    )
    chosen_scalings = random.choices(scaling_methods, k=num_experiments)

    with ProcessPoolExecutor() as executor:
        futures = {
            executor.submit(run_experiment, df, report, t_choice, s_choice, i): i
            for i, (t_choice, s_choice) in enumerate(
                zip(chosen_variations, chosen_scalings)
            )
        }

        for future in futures:
            experiment_id, processed_df = future.result()
            results[experiment_id] = processed_df

    return results


# JSON Report generated by EDA
def load_eda_report(json_file):
    with open(json_file, "r") as f:
        return json.load(f)


#
if __name__ == "__main__":
    eda_report = load_eda_report("../EDA/mlops_eda_report.json")

    # dataset (example)
    df = pd.read_csv("../datasets/Month_Value_1.csv", index_col=0, parse_dates=True)

    # preprocessing
    experiment_results = run_parallel_experiments(df, eda_report, num_experiments=5)
    for exp_id, processed_df in experiment_results.items():
        print(f"Experiment {exp_id} processed data:")
        # print(processed_df.head())
        processed_df.to_csv(f"output/preprocessed_timeseries{exp_id}.csv")

    # Sauvegarder le dataset preprocess√©
    print("Preprocessing finished. Data saved.")
    print(experiment_results.keys())

